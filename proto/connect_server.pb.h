// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connect_server.proto

#ifndef PROTOBUF_connect_5fserver_2eproto__INCLUDED
#define PROTOBUF_connect_5fserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace meet_you
{

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_connect_5fserver_2eproto();
void protobuf_AssignDesc_connect_5fserver_2eproto();
void protobuf_ShutdownFile_connect_5fserver_2eproto();

class LoginRequest;
class LoginResponse;
class ServiceRequest;
class ServiceResponse;
class SvRegRequest;
class SvRegResponse;
class KickCliRequest;

// ===================================================================

class LoginRequest : public ::google::protobuf::Message
{
public:
    LoginRequest();
    virtual ~LoginRequest();

    LoginRequest(const LoginRequest& from);

    inline LoginRequest& operator=(const LoginRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const LoginRequest& default_instance();

    void Swap(LoginRequest* other);

    // implements Message ----------------------------------------------

    LoginRequest* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const LoginRequest& from);
    void MergeFrom(const LoginRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
        return _cached_size_;
    }
private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required string cid = 1;
    inline bool has_cid() const;
    inline void clear_cid();
    static const int kCidFieldNumber = 1;
    inline const ::std::string& cid() const;
    inline void set_cid(const ::std::string& value);
    inline void set_cid(const char* value);
    inline void set_cid(const char* value, size_t size);
    inline ::std::string* mutable_cid();
    inline ::std::string* release_cid();
    inline void set_allocated_cid(::std::string* cid);

    // optional int32 device_type = 2;
    inline bool has_device_type() const;
    inline void clear_device_type();
    static const int kDeviceTypeFieldNumber = 2;
    inline ::google::protobuf::int32 device_type() const;
    inline void set_device_type(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:meet_you.LoginRequest)
private:
    inline void set_has_cid();
    inline void clear_has_cid();
    inline void set_has_device_type();
    inline void clear_has_device_type();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::std::string* cid_;
    ::google::protobuf::int32 device_type_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

    friend void  protobuf_AddDesc_connect_5fserver_2eproto();
    friend void protobuf_AssignDesc_connect_5fserver_2eproto();
    friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

    void InitAsDefaultInstance();
    static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message
{
public:
    LoginResponse();
    virtual ~LoginResponse();

    LoginResponse(const LoginResponse& from);

    inline LoginResponse& operator=(const LoginResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const LoginResponse& default_instance();

    void Swap(LoginResponse* other);

    // implements Message ----------------------------------------------

    LoginResponse* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const LoginResponse& from);
    void MergeFrom(const LoginResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
        return _cached_size_;
    }
private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required int32 status = 1;
    inline bool has_status() const;
    inline void clear_status();
    static const int kStatusFieldNumber = 1;
    inline ::google::protobuf::int32 status() const;
    inline void set_status(::google::protobuf::int32 value);

    // optional string sessid = 2;
    inline bool has_sessid() const;
    inline void clear_sessid();
    static const int kSessidFieldNumber = 2;
    inline const ::std::string& sessid() const;
    inline void set_sessid(const ::std::string& value);
    inline void set_sessid(const char* value);
    inline void set_sessid(const char* value, size_t size);
    inline ::std::string* mutable_sessid();
    inline ::std::string* release_sessid();
    inline void set_allocated_sessid(::std::string* sessid);

    // @@protoc_insertion_point(class_scope:meet_you.LoginResponse)
private:
    inline void set_has_status();
    inline void clear_has_status();
    inline void set_has_sessid();
    inline void clear_has_sessid();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::std::string* sessid_;
    ::google::protobuf::int32 status_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

    friend void  protobuf_AddDesc_connect_5fserver_2eproto();
    friend void protobuf_AssignDesc_connect_5fserver_2eproto();
    friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

    void InitAsDefaultInstance();
    static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServiceRequest : public ::google::protobuf::Message
{
public:
    ServiceRequest();
    virtual ~ServiceRequest();

    ServiceRequest(const ServiceRequest& from);

    inline ServiceRequest& operator=(const ServiceRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ServiceRequest& default_instance();

    void Swap(ServiceRequest* other);

    // implements Message ----------------------------------------------

    ServiceRequest* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ServiceRequest& from);
    void MergeFrom(const ServiceRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
        return _cached_size_;
    }
private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required string sessid = 1;
    inline bool has_sessid() const;
    inline void clear_sessid();
    static const int kSessidFieldNumber = 1;
    inline const ::std::string& sessid() const;
    inline void set_sessid(const ::std::string& value);
    inline void set_sessid(const char* value);
    inline void set_sessid(const char* value, size_t size);
    inline ::std::string* mutable_sessid();
    inline ::std::string* release_sessid();
    inline void set_allocated_sessid(::std::string* sessid);

    // required int32 service_type = 2;
    inline bool has_service_type() const;
    inline void clear_service_type();
    static const int kServiceTypeFieldNumber = 2;
    inline ::google::protobuf::int32 service_type() const;
    inline void set_service_type(::google::protobuf::int32 value);

    // required string sn = 3;
    inline bool has_sn() const;
    inline void clear_sn();
    static const int kSnFieldNumber = 3;
    inline const ::std::string& sn() const;
    inline void set_sn(const ::std::string& value);
    inline void set_sn(const char* value);
    inline void set_sn(const char* value, size_t size);
    inline ::std::string* mutable_sn();
    inline ::std::string* release_sn();
    inline void set_allocated_sn(::std::string* sn);

    // optional bytes payload = 4;
    inline bool has_payload() const;
    inline void clear_payload();
    static const int kPayloadFieldNumber = 4;
    inline const ::std::string& payload() const;
    inline void set_payload(const ::std::string& value);
    inline void set_payload(const char* value);
    inline void set_payload(const void* value, size_t size);
    inline ::std::string* mutable_payload();
    inline ::std::string* release_payload();
    inline void set_allocated_payload(::std::string* payload);

    // @@protoc_insertion_point(class_scope:meet_you.ServiceRequest)
private:
    inline void set_has_sessid();
    inline void clear_has_sessid();
    inline void set_has_service_type();
    inline void clear_has_service_type();
    inline void set_has_sn();
    inline void clear_has_sn();
    inline void set_has_payload();
    inline void clear_has_payload();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::std::string* sessid_;
    ::std::string* sn_;
    ::std::string* payload_;
    ::google::protobuf::int32 service_type_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

    friend void  protobuf_AddDesc_connect_5fserver_2eproto();
    friend void protobuf_AssignDesc_connect_5fserver_2eproto();
    friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

    void InitAsDefaultInstance();
    static ServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse : public ::google::protobuf::Message
{
public:
    ServiceResponse();
    virtual ~ServiceResponse();

    ServiceResponse(const ServiceResponse& from);

    inline ServiceResponse& operator=(const ServiceResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const ServiceResponse& default_instance();

    void Swap(ServiceResponse* other);

    // implements Message ----------------------------------------------

    ServiceResponse* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const ServiceResponse& from);
    void MergeFrom(const ServiceResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
        return _cached_size_;
    }
private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required string sessid = 1;
    inline bool has_sessid() const;
    inline void clear_sessid();
    static const int kSessidFieldNumber = 1;
    inline const ::std::string& sessid() const;
    inline void set_sessid(const ::std::string& value);
    inline void set_sessid(const char* value);
    inline void set_sessid(const char* value, size_t size);
    inline ::std::string* mutable_sessid();
    inline ::std::string* release_sessid();
    inline void set_allocated_sessid(::std::string* sessid);

    // required int32 service_type = 2;
    inline bool has_service_type() const;
    inline void clear_service_type();
    static const int kServiceTypeFieldNumber = 2;
    inline ::google::protobuf::int32 service_type() const;
    inline void set_service_type(::google::protobuf::int32 value);

    // required string sn = 3;
    inline bool has_sn() const;
    inline void clear_sn();
    static const int kSnFieldNumber = 3;
    inline const ::std::string& sn() const;
    inline void set_sn(const ::std::string& value);
    inline void set_sn(const char* value);
    inline void set_sn(const char* value, size_t size);
    inline ::std::string* mutable_sn();
    inline ::std::string* release_sn();
    inline void set_allocated_sn(::std::string* sn);

    // required int32 status = 4;
    inline bool has_status() const;
    inline void clear_status();
    static const int kStatusFieldNumber = 4;
    inline ::google::protobuf::int32 status() const;
    inline void set_status(::google::protobuf::int32 value);

    // optional bytes payload = 5;
    inline bool has_payload() const;
    inline void clear_payload();
    static const int kPayloadFieldNumber = 5;
    inline const ::std::string& payload() const;
    inline void set_payload(const ::std::string& value);
    inline void set_payload(const char* value);
    inline void set_payload(const void* value, size_t size);
    inline ::std::string* mutable_payload();
    inline ::std::string* release_payload();
    inline void set_allocated_payload(::std::string* payload);

    // @@protoc_insertion_point(class_scope:meet_you.ServiceResponse)
private:
    inline void set_has_sessid();
    inline void clear_has_sessid();
    inline void set_has_service_type();
    inline void clear_has_service_type();
    inline void set_has_sn();
    inline void clear_has_sn();
    inline void set_has_status();
    inline void clear_has_status();
    inline void set_has_payload();
    inline void clear_has_payload();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::std::string* sessid_;
    ::std::string* sn_;
    ::google::protobuf::int32 service_type_;
    ::google::protobuf::int32 status_;
    ::std::string* payload_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

    friend void  protobuf_AddDesc_connect_5fserver_2eproto();
    friend void protobuf_AssignDesc_connect_5fserver_2eproto();
    friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

    void InitAsDefaultInstance();
    static ServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class SvRegRequest : public ::google::protobuf::Message
{
public:
    SvRegRequest();
    virtual ~SvRegRequest();

    SvRegRequest(const SvRegRequest& from);

    inline SvRegRequest& operator=(const SvRegRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const SvRegRequest& default_instance();

    void Swap(SvRegRequest* other);

    // implements Message ----------------------------------------------

    SvRegRequest* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const SvRegRequest& from);
    void MergeFrom(const SvRegRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
        return _cached_size_;
    }
private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required int32 service_type = 1;
    inline bool has_service_type() const;
    inline void clear_service_type();
    static const int kServiceTypeFieldNumber = 1;
    inline ::google::protobuf::int32 service_type() const;
    inline void set_service_type(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:meet_you.SvRegRequest)
private:
    inline void set_has_service_type();
    inline void clear_has_service_type();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::int32 service_type_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

    friend void  protobuf_AddDesc_connect_5fserver_2eproto();
    friend void protobuf_AssignDesc_connect_5fserver_2eproto();
    friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

    void InitAsDefaultInstance();
    static SvRegRequest* default_instance_;
};
// -------------------------------------------------------------------

class SvRegResponse : public ::google::protobuf::Message
{
public:
    SvRegResponse();
    virtual ~SvRegResponse();

    SvRegResponse(const SvRegResponse& from);

    inline SvRegResponse& operator=(const SvRegResponse& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const SvRegResponse& default_instance();

    void Swap(SvRegResponse* other);

    // implements Message ----------------------------------------------

    SvRegResponse* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const SvRegResponse& from);
    void MergeFrom(const SvRegResponse& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
        return _cached_size_;
    }
private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // required int32 status = 1;
    inline bool has_status() const;
    inline void clear_status();
    static const int kStatusFieldNumber = 1;
    inline ::google::protobuf::int32 status() const;
    inline void set_status(::google::protobuf::int32 value);

    // @@protoc_insertion_point(class_scope:meet_you.SvRegResponse)
private:
    inline void set_has_status();
    inline void clear_has_status();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::google::protobuf::int32 status_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

    friend void  protobuf_AddDesc_connect_5fserver_2eproto();
    friend void protobuf_AssignDesc_connect_5fserver_2eproto();
    friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

    void InitAsDefaultInstance();
    static SvRegResponse* default_instance_;
};
// -------------------------------------------------------------------

class KickCliRequest : public ::google::protobuf::Message
{
public:
    KickCliRequest();
    virtual ~KickCliRequest();

    KickCliRequest(const KickCliRequest& from);

    inline KickCliRequest& operator=(const KickCliRequest& from)
    {
        CopyFrom(from);
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _unknown_fields_;
    }

    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return &_unknown_fields_;
    }

    static const ::google::protobuf::Descriptor* descriptor();
    static const KickCliRequest& default_instance();

    void Swap(KickCliRequest* other);

    // implements Message ----------------------------------------------

    KickCliRequest* New() const;
    void CopyFrom(const ::google::protobuf::Message& from);
    void MergeFrom(const ::google::protobuf::Message& from);
    void CopyFrom(const KickCliRequest& from);
    void MergeFrom(const KickCliRequest& from);
    void Clear();
    bool IsInitialized() const;

    int ByteSize() const;
    bool MergePartialFromCodedStream(
        ::google::protobuf::io::CodedInputStream* input);
    void SerializeWithCachedSizes(
        ::google::protobuf::io::CodedOutputStream* output) const;
    ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
    int GetCachedSize() const
    {
        return _cached_size_;
    }
private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
public:

    ::google::protobuf::Metadata GetMetadata() const;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // optional bytes reason = 1;
    inline bool has_reason() const;
    inline void clear_reason();
    static const int kReasonFieldNumber = 1;
    inline const ::std::string& reason() const;
    inline void set_reason(const ::std::string& value);
    inline void set_reason(const char* value);
    inline void set_reason(const void* value, size_t size);
    inline ::std::string* mutable_reason();
    inline ::std::string* release_reason();
    inline void set_allocated_reason(::std::string* reason);

    // @@protoc_insertion_point(class_scope:meet_you.KickCliRequest)
private:
    inline void set_has_reason();
    inline void clear_has_reason();

    ::google::protobuf::UnknownFieldSet _unknown_fields_;

    ::std::string* reason_;

    mutable int _cached_size_;
    ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

    friend void  protobuf_AddDesc_connect_5fserver_2eproto();
    friend void protobuf_AssignDesc_connect_5fserver_2eproto();
    friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

    void InitAsDefaultInstance();
    static KickCliRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string cid = 1;
inline bool LoginRequest::has_cid() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_cid()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_cid()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_cid()
{
    if (cid_ != &::google::protobuf::internal::kEmptyString)
    {
        cid_->clear();
    }
    clear_has_cid();
}
inline const ::std::string& LoginRequest::cid() const
{
    return *cid_;
}
inline void LoginRequest::set_cid(const ::std::string& value)
{
    set_has_cid();
    if (cid_ == &::google::protobuf::internal::kEmptyString)
    {
        cid_ = new ::std::string;
    }
    cid_->assign(value);
}
inline void LoginRequest::set_cid(const char* value)
{
    set_has_cid();
    if (cid_ == &::google::protobuf::internal::kEmptyString)
    {
        cid_ = new ::std::string;
    }
    cid_->assign(value);
}
inline void LoginRequest::set_cid(const char* value, size_t size)
{
    set_has_cid();
    if (cid_ == &::google::protobuf::internal::kEmptyString)
    {
        cid_ = new ::std::string;
    }
    cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_cid()
{
    set_has_cid();
    if (cid_ == &::google::protobuf::internal::kEmptyString)
    {
        cid_ = new ::std::string;
    }
    return cid_;
}
inline ::std::string* LoginRequest::release_cid()
{
    clear_has_cid();
    if (cid_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = cid_;
        cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void LoginRequest::set_allocated_cid(::std::string* cid)
{
    if (cid_ != &::google::protobuf::internal::kEmptyString)
    {
        delete cid_;
    }
    if (cid)
    {
        set_has_cid();
        cid_ = cid;
    }
    else
    {
        clear_has_cid();
        cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// optional int32 device_type = 2;
inline bool LoginRequest::has_device_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_device_type()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_device_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_device_type()
{
    device_type_ = 0;
    clear_has_device_type();
}
inline ::google::protobuf::int32 LoginRequest::device_type() const
{
    return device_type_;
}
inline void LoginRequest::set_device_type(::google::protobuf::int32 value)
{
    set_has_device_type();
    device_type_ = value;
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 status = 1;
inline bool LoginResponse::has_status() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_status()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_status()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_status()
{
    status_ = 0;
    clear_has_status();
}
inline ::google::protobuf::int32 LoginResponse::status() const
{
    return status_;
}
inline void LoginResponse::set_status(::google::protobuf::int32 value)
{
    set_has_status();
    status_ = value;
}

// optional string sessid = 2;
inline bool LoginResponse::has_sessid() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_sessid()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_sessid()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_sessid()
{
    if (sessid_ != &::google::protobuf::internal::kEmptyString)
    {
        sessid_->clear();
    }
    clear_has_sessid();
}
inline const ::std::string& LoginResponse::sessid() const
{
    return *sessid_;
}
inline void LoginResponse::set_sessid(const ::std::string& value)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value, size_t size)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_sessid()
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    return sessid_;
}
inline ::std::string* LoginResponse::release_sessid()
{
    clear_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = sessid_;
        sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void LoginResponse::set_allocated_sessid(::std::string* sessid)
{
    if (sessid_ != &::google::protobuf::internal::kEmptyString)
    {
        delete sessid_;
    }
    if (sessid)
    {
        set_has_sessid();
        sessid_ = sessid;
    }
    else
    {
        clear_has_sessid();
        sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// -------------------------------------------------------------------

// ServiceRequest

// required string sessid = 1;
inline bool ServiceRequest::has_sessid() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest::set_has_sessid()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest::clear_has_sessid()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest::clear_sessid()
{
    if (sessid_ != &::google::protobuf::internal::kEmptyString)
    {
        sessid_->clear();
    }
    clear_has_sessid();
}
inline const ::std::string& ServiceRequest::sessid() const
{
    return *sessid_;
}
inline void ServiceRequest::set_sessid(const ::std::string& value)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(value);
}
inline void ServiceRequest::set_sessid(const char* value)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(value);
}
inline void ServiceRequest::set_sessid(const char* value, size_t size)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_sessid()
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    return sessid_;
}
inline ::std::string* ServiceRequest::release_sessid()
{
    clear_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = sessid_;
        sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void ServiceRequest::set_allocated_sessid(::std::string* sessid)
{
    if (sessid_ != &::google::protobuf::internal::kEmptyString)
    {
        delete sessid_;
    }
    if (sessid)
    {
        set_has_sessid();
        sessid_ = sessid;
    }
    else
    {
        clear_has_sessid();
        sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// required int32 service_type = 2;
inline bool ServiceRequest::has_service_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceRequest::set_has_service_type()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ServiceRequest::clear_has_service_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceRequest::clear_service_type()
{
    service_type_ = 0;
    clear_has_service_type();
}
inline ::google::protobuf::int32 ServiceRequest::service_type() const
{
    return service_type_;
}
inline void ServiceRequest::set_service_type(::google::protobuf::int32 value)
{
    set_has_service_type();
    service_type_ = value;
}

// required string sn = 3;
inline bool ServiceRequest::has_sn() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceRequest::set_has_sn()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void ServiceRequest::clear_has_sn()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceRequest::clear_sn()
{
    if (sn_ != &::google::protobuf::internal::kEmptyString)
    {
        sn_->clear();
    }
    clear_has_sn();
}
inline const ::std::string& ServiceRequest::sn() const
{
    return *sn_;
}
inline void ServiceRequest::set_sn(const ::std::string& value)
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value)
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value, size_t size)
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_sn()
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    return sn_;
}
inline ::std::string* ServiceRequest::release_sn()
{
    clear_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = sn_;
        sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void ServiceRequest::set_allocated_sn(::std::string* sn)
{
    if (sn_ != &::google::protobuf::internal::kEmptyString)
    {
        delete sn_;
    }
    if (sn)
    {
        set_has_sn();
        sn_ = sn;
    }
    else
    {
        clear_has_sn();
        sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// optional bytes payload = 4;
inline bool ServiceRequest::has_payload() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceRequest::set_has_payload()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void ServiceRequest::clear_has_payload()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceRequest::clear_payload()
{
    if (payload_ != &::google::protobuf::internal::kEmptyString)
    {
        payload_->clear();
    }
    clear_has_payload();
}
inline const ::std::string& ServiceRequest::payload() const
{
    return *payload_;
}
inline void ServiceRequest::set_payload(const ::std::string& value)
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    payload_->assign(value);
}
inline void ServiceRequest::set_payload(const char* value)
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    payload_->assign(value);
}
inline void ServiceRequest::set_payload(const void* value, size_t size)
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_payload()
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    return payload_;
}
inline ::std::string* ServiceRequest::release_payload()
{
    clear_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = payload_;
        payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void ServiceRequest::set_allocated_payload(::std::string* payload)
{
    if (payload_ != &::google::protobuf::internal::kEmptyString)
    {
        delete payload_;
    }
    if (payload)
    {
        set_has_payload();
        payload_ = payload;
    }
    else
    {
        clear_has_payload();
        payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// -------------------------------------------------------------------

// ServiceResponse

// required string sessid = 1;
inline bool ServiceResponse::has_sessid() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse::set_has_sessid()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse::clear_has_sessid()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse::clear_sessid()
{
    if (sessid_ != &::google::protobuf::internal::kEmptyString)
    {
        sessid_->clear();
    }
    clear_has_sessid();
}
inline const ::std::string& ServiceResponse::sessid() const
{
    return *sessid_;
}
inline void ServiceResponse::set_sessid(const ::std::string& value)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(value);
}
inline void ServiceResponse::set_sessid(const char* value)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(value);
}
inline void ServiceResponse::set_sessid(const char* value, size_t size)
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_sessid()
{
    set_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        sessid_ = new ::std::string;
    }
    return sessid_;
}
inline ::std::string* ServiceResponse::release_sessid()
{
    clear_has_sessid();
    if (sessid_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = sessid_;
        sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void ServiceResponse::set_allocated_sessid(::std::string* sessid)
{
    if (sessid_ != &::google::protobuf::internal::kEmptyString)
    {
        delete sessid_;
    }
    if (sessid)
    {
        set_has_sessid();
        sessid_ = sessid;
    }
    else
    {
        clear_has_sessid();
        sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// required int32 service_type = 2;
inline bool ServiceResponse::has_service_type() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse::set_has_service_type()
{
    _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse::clear_has_service_type()
{
    _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse::clear_service_type()
{
    service_type_ = 0;
    clear_has_service_type();
}
inline ::google::protobuf::int32 ServiceResponse::service_type() const
{
    return service_type_;
}
inline void ServiceResponse::set_service_type(::google::protobuf::int32 value)
{
    set_has_service_type();
    service_type_ = value;
}

// required string sn = 3;
inline bool ServiceResponse::has_sn() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceResponse::set_has_sn()
{
    _has_bits_[0] |= 0x00000004u;
}
inline void ServiceResponse::clear_has_sn()
{
    _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceResponse::clear_sn()
{
    if (sn_ != &::google::protobuf::internal::kEmptyString)
    {
        sn_->clear();
    }
    clear_has_sn();
}
inline const ::std::string& ServiceResponse::sn() const
{
    return *sn_;
}
inline void ServiceResponse::set_sn(const ::std::string& value)
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value)
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value, size_t size)
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_sn()
{
    set_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        sn_ = new ::std::string;
    }
    return sn_;
}
inline ::std::string* ServiceResponse::release_sn()
{
    clear_has_sn();
    if (sn_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = sn_;
        sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void ServiceResponse::set_allocated_sn(::std::string* sn)
{
    if (sn_ != &::google::protobuf::internal::kEmptyString)
    {
        delete sn_;
    }
    if (sn)
    {
        set_has_sn();
        sn_ = sn;
    }
    else
    {
        clear_has_sn();
        sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// required int32 status = 4;
inline bool ServiceResponse::has_status() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceResponse::set_has_status()
{
    _has_bits_[0] |= 0x00000008u;
}
inline void ServiceResponse::clear_has_status()
{
    _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceResponse::clear_status()
{
    status_ = 0;
    clear_has_status();
}
inline ::google::protobuf::int32 ServiceResponse::status() const
{
    return status_;
}
inline void ServiceResponse::set_status(::google::protobuf::int32 value)
{
    set_has_status();
    status_ = value;
}

// optional bytes payload = 5;
inline bool ServiceResponse::has_payload() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceResponse::set_has_payload()
{
    _has_bits_[0] |= 0x00000010u;
}
inline void ServiceResponse::clear_has_payload()
{
    _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceResponse::clear_payload()
{
    if (payload_ != &::google::protobuf::internal::kEmptyString)
    {
        payload_->clear();
    }
    clear_has_payload();
}
inline const ::std::string& ServiceResponse::payload() const
{
    return *payload_;
}
inline void ServiceResponse::set_payload(const ::std::string& value)
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    payload_->assign(value);
}
inline void ServiceResponse::set_payload(const char* value)
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    payload_->assign(value);
}
inline void ServiceResponse::set_payload(const void* value, size_t size)
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_payload()
{
    set_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        payload_ = new ::std::string;
    }
    return payload_;
}
inline ::std::string* ServiceResponse::release_payload()
{
    clear_has_payload();
    if (payload_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = payload_;
        payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void ServiceResponse::set_allocated_payload(::std::string* payload)
{
    if (payload_ != &::google::protobuf::internal::kEmptyString)
    {
        delete payload_;
    }
    if (payload)
    {
        set_has_payload();
        payload_ = payload;
    }
    else
    {
        clear_has_payload();
        payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}

// -------------------------------------------------------------------

// SvRegRequest

// required int32 service_type = 1;
inline bool SvRegRequest::has_service_type() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SvRegRequest::set_has_service_type()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void SvRegRequest::clear_has_service_type()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void SvRegRequest::clear_service_type()
{
    service_type_ = 0;
    clear_has_service_type();
}
inline ::google::protobuf::int32 SvRegRequest::service_type() const
{
    return service_type_;
}
inline void SvRegRequest::set_service_type(::google::protobuf::int32 value)
{
    set_has_service_type();
    service_type_ = value;
}

// -------------------------------------------------------------------

// SvRegResponse

// required int32 status = 1;
inline bool SvRegResponse::has_status() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SvRegResponse::set_has_status()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void SvRegResponse::clear_has_status()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void SvRegResponse::clear_status()
{
    status_ = 0;
    clear_has_status();
}
inline ::google::protobuf::int32 SvRegResponse::status() const
{
    return status_;
}
inline void SvRegResponse::set_status(::google::protobuf::int32 value)
{
    set_has_status();
    status_ = value;
}

// -------------------------------------------------------------------

// KickCliRequest

// optional bytes reason = 1;
inline bool KickCliRequest::has_reason() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickCliRequest::set_has_reason()
{
    _has_bits_[0] |= 0x00000001u;
}
inline void KickCliRequest::clear_has_reason()
{
    _has_bits_[0] &= ~0x00000001u;
}
inline void KickCliRequest::clear_reason()
{
    if (reason_ != &::google::protobuf::internal::kEmptyString)
    {
        reason_->clear();
    }
    clear_has_reason();
}
inline const ::std::string& KickCliRequest::reason() const
{
    return *reason_;
}
inline void KickCliRequest::set_reason(const ::std::string& value)
{
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::kEmptyString)
    {
        reason_ = new ::std::string;
    }
    reason_->assign(value);
}
inline void KickCliRequest::set_reason(const char* value)
{
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::kEmptyString)
    {
        reason_ = new ::std::string;
    }
    reason_->assign(value);
}
inline void KickCliRequest::set_reason(const void* value, size_t size)
{
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::kEmptyString)
    {
        reason_ = new ::std::string;
    }
    reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_reason()
{
    set_has_reason();
    if (reason_ == &::google::protobuf::internal::kEmptyString)
    {
        reason_ = new ::std::string;
    }
    return reason_;
}
inline ::std::string* KickCliRequest::release_reason()
{
    clear_has_reason();
    if (reason_ == &::google::protobuf::internal::kEmptyString)
    {
        return NULL;
    }
    else
    {
        ::std::string* temp = reason_;
        reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        return temp;
    }
}
inline void KickCliRequest::set_allocated_reason(::std::string* reason)
{
    if (reason_ != &::google::protobuf::internal::kEmptyString)
    {
        delete reason_;
    }
    if (reason)
    {
        set_has_reason();
        reason_ = reason;
    }
    else
    {
        clear_has_reason();
        reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace meet_you

#ifndef SWIG
namespace google
{
namespace protobuf
{


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_connect_5fserver_2eproto__INCLUDED
