// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ServicePacket.proto

#ifndef PROTOBUF_ServicePacket_2eproto__INCLUDED
#define PROTOBUF_ServicePacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ServicePacket_2eproto();
void protobuf_AssignDesc_ServicePacket_2eproto();
void protobuf_ShutdownFile_ServicePacket_2eproto();

class ReplyRequest;
class ReplyResponse;
class PostTopicRequest;
class PostTopicResponse;
class PublicServiceRequest;
class PublicServiceResponse;
class GroupLBSNearRequest;
class GroupLBSNearResponse;
class GroupCityRequest;
class GroupCityResponse;
class PythonCoreRequest;
class PythonCoreResponse;
class ServicePacket;

// ===================================================================

class ReplyRequest : public ::google::protobuf::Message {
 public:
  ReplyRequest();
  virtual ~ReplyRequest();

  ReplyRequest(const ReplyRequest& from);

  inline ReplyRequest& operator=(const ReplyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyRequest& default_instance();

  void Swap(ReplyRequest* other);

  // implements Message ----------------------------------------------

  ReplyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyRequest& from);
  void MergeFrom(const ReplyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional int64 expiry = 3;
  inline bool has_expiry() const;
  inline void clear_expiry();
  static const int kExpiryFieldNumber = 3;
  inline ::google::protobuf::int64 expiry() const;
  inline void set_expiry(::google::protobuf::int64 value);

  // optional string topic_id = 4;
  inline bool has_topic_id() const;
  inline void clear_topic_id();
  static const int kTopicIdFieldNumber = 4;
  inline const ::std::string& topic_id() const;
  inline void set_topic_id(const ::std::string& value);
  inline void set_topic_id(const char* value);
  inline void set_topic_id(const char* value, size_t size);
  inline ::std::string* mutable_topic_id();
  inline ::std::string* release_topic_id();
  inline void set_allocated_topic_id(::std::string* topic_id);

  // optional string sign = 5;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 5;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // optional string v = 6;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 6;
  inline const ::std::string& v() const;
  inline void set_v(const ::std::string& value);
  inline void set_v(const char* value);
  inline void set_v(const char* value, size_t size);
  inline ::std::string* mutable_v();
  inline ::std::string* release_v();
  inline void set_allocated_v(::std::string* v);

  // optional string platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string device_id = 8;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 8;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string authorization = 9;
  inline bool has_authorization() const;
  inline void clear_authorization();
  static const int kAuthorizationFieldNumber = 9;
  inline const ::std::string& authorization() const;
  inline void set_authorization(const ::std::string& value);
  inline void set_authorization(const char* value);
  inline void set_authorization(const char* value, size_t size);
  inline ::std::string* mutable_authorization();
  inline ::std::string* release_authorization();
  inline void set_allocated_authorization(::std::string* authorization);

  // optional bytes data = 10;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 10;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:ReplyRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_expiry();
  inline void clear_has_expiry();
  inline void set_has_topic_id();
  inline void clear_has_topic_id();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_authorization();
  inline void clear_has_authorization();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* type_;
  ::google::protobuf::int64 expiry_;
  ::std::string* topic_id_;
  ::std::string* sign_;
  ::std::string* v_;
  ::std::string* platform_;
  ::std::string* device_id_;
  ::std::string* authorization_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static ReplyRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReplyResponse : public ::google::protobuf::Message {
 public:
  ReplyResponse();
  virtual ~ReplyResponse();

  ReplyResponse(const ReplyResponse& from);

  inline ReplyResponse& operator=(const ReplyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyResponse& default_instance();

  void Swap(ReplyResponse* other);

  // implements Message ----------------------------------------------

  ReplyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyResponse& from);
  void MergeFrom(const ReplyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:ReplyResponse)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* type_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static ReplyResponse* default_instance_;
};
// -------------------------------------------------------------------

class PostTopicRequest : public ::google::protobuf::Message {
 public:
  PostTopicRequest();
  virtual ~PostTopicRequest();

  PostTopicRequest(const PostTopicRequest& from);

  inline PostTopicRequest& operator=(const PostTopicRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostTopicRequest& default_instance();

  void Swap(PostTopicRequest* other);

  // implements Message ----------------------------------------------

  PostTopicRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostTopicRequest& from);
  void MergeFrom(const PostTopicRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional int64 expiry = 3;
  inline bool has_expiry() const;
  inline void clear_expiry();
  static const int kExpiryFieldNumber = 3;
  inline ::google::protobuf::int64 expiry() const;
  inline void set_expiry(::google::protobuf::int64 value);

  // optional string forum_id = 4;
  inline bool has_forum_id() const;
  inline void clear_forum_id();
  static const int kForumIdFieldNumber = 4;
  inline const ::std::string& forum_id() const;
  inline void set_forum_id(const ::std::string& value);
  inline void set_forum_id(const char* value);
  inline void set_forum_id(const char* value, size_t size);
  inline ::std::string* mutable_forum_id();
  inline ::std::string* release_forum_id();
  inline void set_allocated_forum_id(::std::string* forum_id);

  // optional string sign = 5;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 5;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // optional string v = 6;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 6;
  inline const ::std::string& v() const;
  inline void set_v(const ::std::string& value);
  inline void set_v(const char* value);
  inline void set_v(const char* value, size_t size);
  inline ::std::string* mutable_v();
  inline ::std::string* release_v();
  inline void set_allocated_v(::std::string* v);

  // optional string platform = 7;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 7;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string device_id = 8;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 8;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string authorization = 9;
  inline bool has_authorization() const;
  inline void clear_authorization();
  static const int kAuthorizationFieldNumber = 9;
  inline const ::std::string& authorization() const;
  inline void set_authorization(const ::std::string& value);
  inline void set_authorization(const char* value);
  inline void set_authorization(const char* value, size_t size);
  inline ::std::string* mutable_authorization();
  inline ::std::string* release_authorization();
  inline void set_allocated_authorization(::std::string* authorization);

  // optional bytes data = 10;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 10;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:PostTopicRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_expiry();
  inline void clear_has_expiry();
  inline void set_has_forum_id();
  inline void clear_has_forum_id();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_v();
  inline void clear_has_v();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_authorization();
  inline void clear_has_authorization();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* type_;
  ::google::protobuf::int64 expiry_;
  ::std::string* forum_id_;
  ::std::string* sign_;
  ::std::string* v_;
  ::std::string* platform_;
  ::std::string* device_id_;
  ::std::string* authorization_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static PostTopicRequest* default_instance_;
};
// -------------------------------------------------------------------

class PostTopicResponse : public ::google::protobuf::Message {
 public:
  PostTopicResponse();
  virtual ~PostTopicResponse();

  PostTopicResponse(const PostTopicResponse& from);

  inline PostTopicResponse& operator=(const PostTopicResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PostTopicResponse& default_instance();

  void Swap(PostTopicResponse* other);

  // implements Message ----------------------------------------------

  PostTopicResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostTopicResponse& from);
  void MergeFrom(const PostTopicResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:PostTopicResponse)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* type_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static PostTopicResponse* default_instance_;
};
// -------------------------------------------------------------------

class PublicServiceRequest : public ::google::protobuf::Message {
 public:
  PublicServiceRequest();
  virtual ~PublicServiceRequest();

  PublicServiceRequest(const PublicServiceRequest& from);

  inline PublicServiceRequest& operator=(const PublicServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicServiceRequest& default_instance();

  void Swap(PublicServiceRequest* other);

  // implements Message ----------------------------------------------

  PublicServiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicServiceRequest& from);
  void MergeFrom(const PublicServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string service_id = 2;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 2;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:PublicServiceRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* service_id_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static PublicServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class PublicServiceResponse : public ::google::protobuf::Message {
 public:
  PublicServiceResponse();
  virtual ~PublicServiceResponse();

  PublicServiceResponse(const PublicServiceResponse& from);

  inline PublicServiceResponse& operator=(const PublicServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicServiceResponse& default_instance();

  void Swap(PublicServiceResponse* other);

  // implements Message ----------------------------------------------

  PublicServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicServiceResponse& from);
  void MergeFrom(const PublicServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string service_id = 2;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 2;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PublicServiceResponse)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* service_id_;
  ::std::string* data_;
  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static PublicServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class GroupLBSNearRequest : public ::google::protobuf::Message {
 public:
  GroupLBSNearRequest();
  virtual ~GroupLBSNearRequest();

  GroupLBSNearRequest(const GroupLBSNearRequest& from);

  inline GroupLBSNearRequest& operator=(const GroupLBSNearRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupLBSNearRequest& default_instance();

  void Swap(GroupLBSNearRequest* other);

  // implements Message ----------------------------------------------

  GroupLBSNearRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupLBSNearRequest& from);
  void MergeFrom(const GroupLBSNearRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double long = 3;
  inline bool has_long_() const;
  inline void clear_long_();
  static const int kLongFieldNumber = 3;
  inline double long_() const;
  inline void set_long_(double value);

  // optional int32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 limit = 5;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 5;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // optional int32 max_distance = 6;
  inline bool has_max_distance() const;
  inline void clear_max_distance();
  static const int kMaxDistanceFieldNumber = 6;
  inline ::google::protobuf::int32 max_distance() const;
  inline void set_max_distance(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupLBSNearRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_long_();
  inline void clear_has_long_();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_max_distance();
  inline void clear_has_max_distance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  double lat_;
  double long__;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 max_distance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static GroupLBSNearRequest* default_instance_;
};
// -------------------------------------------------------------------

class GroupLBSNearResponse : public ::google::protobuf::Message {
 public:
  GroupLBSNearResponse();
  virtual ~GroupLBSNearResponse();

  GroupLBSNearResponse(const GroupLBSNearResponse& from);

  inline GroupLBSNearResponse& operator=(const GroupLBSNearResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupLBSNearResponse& default_instance();

  void Swap(GroupLBSNearResponse* other);

  // implements Message ----------------------------------------------

  GroupLBSNearResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupLBSNearResponse& from);
  void MergeFrom(const GroupLBSNearResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:GroupLBSNearResponse)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* data_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static GroupLBSNearResponse* default_instance_;
};
// -------------------------------------------------------------------

class GroupCityRequest : public ::google::protobuf::Message {
 public:
  GroupCityRequest();
  virtual ~GroupCityRequest();

  GroupCityRequest(const GroupCityRequest& from);

  inline GroupCityRequest& operator=(const GroupCityRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupCityRequest& default_instance();

  void Swap(GroupCityRequest* other);

  // implements Message ----------------------------------------------

  GroupCityRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupCityRequest& from);
  void MergeFrom(const GroupCityRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string city = 2;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 2;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional int32 start = 3;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 3;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GroupCityRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* city_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static GroupCityRequest* default_instance_;
};
// -------------------------------------------------------------------

class GroupCityResponse : public ::google::protobuf::Message {
 public:
  GroupCityResponse();
  virtual ~GroupCityResponse();

  GroupCityResponse(const GroupCityResponse& from);

  inline GroupCityResponse& operator=(const GroupCityResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupCityResponse& default_instance();

  void Swap(GroupCityResponse* other);

  // implements Message ----------------------------------------------

  GroupCityResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupCityResponse& from);
  void MergeFrom(const GroupCityResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:GroupCityResponse)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* data_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static GroupCityResponse* default_instance_;
};
// -------------------------------------------------------------------

class PythonCoreRequest : public ::google::protobuf::Message {
 public:
  PythonCoreRequest();
  virtual ~PythonCoreRequest();

  PythonCoreRequest(const PythonCoreRequest& from);

  inline PythonCoreRequest& operator=(const PythonCoreRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PythonCoreRequest& default_instance();

  void Swap(PythonCoreRequest* other);

  // implements Message ----------------------------------------------

  PythonCoreRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PythonCoreRequest& from);
  void MergeFrom(const PythonCoreRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string json_request = 2;
  inline bool has_json_request() const;
  inline void clear_json_request();
  static const int kJsonRequestFieldNumber = 2;
  inline const ::std::string& json_request() const;
  inline void set_json_request(const ::std::string& value);
  inline void set_json_request(const char* value);
  inline void set_json_request(const char* value, size_t size);
  inline ::std::string* mutable_json_request();
  inline ::std::string* release_json_request();
  inline void set_allocated_json_request(::std::string* json_request);

  // optional string module_name = 3;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 3;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  inline void set_allocated_module_name(::std::string* module_name);

  // optional string function_name = 4;
  inline bool has_function_name() const;
  inline void clear_function_name();
  static const int kFunctionNameFieldNumber = 4;
  inline const ::std::string& function_name() const;
  inline void set_function_name(const ::std::string& value);
  inline void set_function_name(const char* value);
  inline void set_function_name(const char* value, size_t size);
  inline ::std::string* mutable_function_name();
  inline ::std::string* release_function_name();
  inline void set_allocated_function_name(::std::string* function_name);

  // @@protoc_insertion_point(class_scope:PythonCoreRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_json_request();
  inline void clear_has_json_request();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  inline void set_has_function_name();
  inline void clear_has_function_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* json_request_;
  ::std::string* module_name_;
  ::std::string* function_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static PythonCoreRequest* default_instance_;
};
// -------------------------------------------------------------------

class PythonCoreResponse : public ::google::protobuf::Message {
 public:
  PythonCoreResponse();
  virtual ~PythonCoreResponse();

  PythonCoreResponse(const PythonCoreResponse& from);

  inline PythonCoreResponse& operator=(const PythonCoreResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PythonCoreResponse& default_instance();

  void Swap(PythonCoreResponse* other);

  // implements Message ----------------------------------------------

  PythonCoreResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PythonCoreResponse& from);
  void MergeFrom(const PythonCoreResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string json_response = 2;
  inline bool has_json_response() const;
  inline void clear_json_response();
  static const int kJsonResponseFieldNumber = 2;
  inline const ::std::string& json_response() const;
  inline void set_json_response(const ::std::string& value);
  inline void set_json_response(const char* value);
  inline void set_json_response(const char* value, size_t size);
  inline ::std::string* mutable_json_response();
  inline ::std::string* release_json_response();
  inline void set_allocated_json_response(::std::string* json_response);

  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PythonCoreResponse)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_json_response();
  inline void clear_has_json_response();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cid_;
  ::std::string* json_response_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static PythonCoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServicePacket : public ::google::protobuf::Message {
 public:
  ServicePacket();
  virtual ~ServicePacket();

  ServicePacket(const ServicePacket& from);

  inline ServicePacket& operator=(const ServicePacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServicePacket& default_instance();

  void Swap(ServicePacket* other);

  // implements Message ----------------------------------------------

  ServicePacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServicePacket& from);
  void MergeFrom(const ServicePacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional .ReplyRequest reply_request = 2;
  inline bool has_reply_request() const;
  inline void clear_reply_request();
  static const int kReplyRequestFieldNumber = 2;
  inline const ::ReplyRequest& reply_request() const;
  inline ::ReplyRequest* mutable_reply_request();
  inline ::ReplyRequest* release_reply_request();
  inline void set_allocated_reply_request(::ReplyRequest* reply_request);

  // optional .ReplyResponse reply_response = 3;
  inline bool has_reply_response() const;
  inline void clear_reply_response();
  static const int kReplyResponseFieldNumber = 3;
  inline const ::ReplyResponse& reply_response() const;
  inline ::ReplyResponse* mutable_reply_response();
  inline ::ReplyResponse* release_reply_response();
  inline void set_allocated_reply_response(::ReplyResponse* reply_response);

  // optional .PostTopicRequest post_topic_request = 4;
  inline bool has_post_topic_request() const;
  inline void clear_post_topic_request();
  static const int kPostTopicRequestFieldNumber = 4;
  inline const ::PostTopicRequest& post_topic_request() const;
  inline ::PostTopicRequest* mutable_post_topic_request();
  inline ::PostTopicRequest* release_post_topic_request();
  inline void set_allocated_post_topic_request(::PostTopicRequest* post_topic_request);

  // optional .PostTopicResponse post_topic_response = 5;
  inline bool has_post_topic_response() const;
  inline void clear_post_topic_response();
  static const int kPostTopicResponseFieldNumber = 5;
  inline const ::PostTopicResponse& post_topic_response() const;
  inline ::PostTopicResponse* mutable_post_topic_response();
  inline ::PostTopicResponse* release_post_topic_response();
  inline void set_allocated_post_topic_response(::PostTopicResponse* post_topic_response);

  // optional .PublicServiceRequest public_service_request = 6;
  inline bool has_public_service_request() const;
  inline void clear_public_service_request();
  static const int kPublicServiceRequestFieldNumber = 6;
  inline const ::PublicServiceRequest& public_service_request() const;
  inline ::PublicServiceRequest* mutable_public_service_request();
  inline ::PublicServiceRequest* release_public_service_request();
  inline void set_allocated_public_service_request(::PublicServiceRequest* public_service_request);

  // optional .PublicServiceResponse public_service_response = 7;
  inline bool has_public_service_response() const;
  inline void clear_public_service_response();
  static const int kPublicServiceResponseFieldNumber = 7;
  inline const ::PublicServiceResponse& public_service_response() const;
  inline ::PublicServiceResponse* mutable_public_service_response();
  inline ::PublicServiceResponse* release_public_service_response();
  inline void set_allocated_public_service_response(::PublicServiceResponse* public_service_response);

  // optional .GroupLBSNearRequest group_lbs_near_request = 8;
  inline bool has_group_lbs_near_request() const;
  inline void clear_group_lbs_near_request();
  static const int kGroupLbsNearRequestFieldNumber = 8;
  inline const ::GroupLBSNearRequest& group_lbs_near_request() const;
  inline ::GroupLBSNearRequest* mutable_group_lbs_near_request();
  inline ::GroupLBSNearRequest* release_group_lbs_near_request();
  inline void set_allocated_group_lbs_near_request(::GroupLBSNearRequest* group_lbs_near_request);

  // optional .GroupLBSNearResponse group_lbs_near_response = 9;
  inline bool has_group_lbs_near_response() const;
  inline void clear_group_lbs_near_response();
  static const int kGroupLbsNearResponseFieldNumber = 9;
  inline const ::GroupLBSNearResponse& group_lbs_near_response() const;
  inline ::GroupLBSNearResponse* mutable_group_lbs_near_response();
  inline ::GroupLBSNearResponse* release_group_lbs_near_response();
  inline void set_allocated_group_lbs_near_response(::GroupLBSNearResponse* group_lbs_near_response);

  // optional .GroupCityRequest group_city_request = 10;
  inline bool has_group_city_request() const;
  inline void clear_group_city_request();
  static const int kGroupCityRequestFieldNumber = 10;
  inline const ::GroupCityRequest& group_city_request() const;
  inline ::GroupCityRequest* mutable_group_city_request();
  inline ::GroupCityRequest* release_group_city_request();
  inline void set_allocated_group_city_request(::GroupCityRequest* group_city_request);

  // optional .GroupCityResponse group_city_response = 11;
  inline bool has_group_city_response() const;
  inline void clear_group_city_response();
  static const int kGroupCityResponseFieldNumber = 11;
  inline const ::GroupCityResponse& group_city_response() const;
  inline ::GroupCityResponse* mutable_group_city_response();
  inline ::GroupCityResponse* release_group_city_response();
  inline void set_allocated_group_city_response(::GroupCityResponse* group_city_response);

  // optional .PythonCoreRequest python_core_request = 12;
  inline bool has_python_core_request() const;
  inline void clear_python_core_request();
  static const int kPythonCoreRequestFieldNumber = 12;
  inline const ::PythonCoreRequest& python_core_request() const;
  inline ::PythonCoreRequest* mutable_python_core_request();
  inline ::PythonCoreRequest* release_python_core_request();
  inline void set_allocated_python_core_request(::PythonCoreRequest* python_core_request);

  // optional .PythonCoreResponse python_core_response = 13;
  inline bool has_python_core_response() const;
  inline void clear_python_core_response();
  static const int kPythonCoreResponseFieldNumber = 13;
  inline const ::PythonCoreResponse& python_core_response() const;
  inline ::PythonCoreResponse* mutable_python_core_response();
  inline ::PythonCoreResponse* release_python_core_response();
  inline void set_allocated_python_core_response(::PythonCoreResponse* python_core_response);

  // @@protoc_insertion_point(class_scope:ServicePacket)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reply_request();
  inline void clear_has_reply_request();
  inline void set_has_reply_response();
  inline void clear_has_reply_response();
  inline void set_has_post_topic_request();
  inline void clear_has_post_topic_request();
  inline void set_has_post_topic_response();
  inline void clear_has_post_topic_response();
  inline void set_has_public_service_request();
  inline void clear_has_public_service_request();
  inline void set_has_public_service_response();
  inline void clear_has_public_service_response();
  inline void set_has_group_lbs_near_request();
  inline void clear_has_group_lbs_near_request();
  inline void set_has_group_lbs_near_response();
  inline void clear_has_group_lbs_near_response();
  inline void set_has_group_city_request();
  inline void clear_has_group_city_request();
  inline void set_has_group_city_response();
  inline void clear_has_group_city_response();
  inline void set_has_python_core_request();
  inline void clear_has_python_core_request();
  inline void set_has_python_core_response();
  inline void clear_has_python_core_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReplyRequest* reply_request_;
  ::ReplyResponse* reply_response_;
  ::PostTopicRequest* post_topic_request_;
  ::PostTopicResponse* post_topic_response_;
  ::PublicServiceRequest* public_service_request_;
  ::PublicServiceResponse* public_service_response_;
  ::GroupLBSNearRequest* group_lbs_near_request_;
  ::GroupLBSNearResponse* group_lbs_near_response_;
  ::GroupCityRequest* group_city_request_;
  ::GroupCityResponse* group_city_response_;
  ::PythonCoreRequest* python_core_request_;
  ::PythonCoreResponse* python_core_response_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ServicePacket_2eproto();
  friend void protobuf_AssignDesc_ServicePacket_2eproto();
  friend void protobuf_ShutdownFile_ServicePacket_2eproto();

  void InitAsDefaultInstance();
  static ServicePacket* default_instance_;
};
// ===================================================================


// ===================================================================

// ReplyRequest

// optional string cid = 1;
inline bool ReplyRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplyRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplyRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplyRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& ReplyRequest::cid() const {
  return *cid_;
}
inline void ReplyRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void ReplyRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void ReplyRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* ReplyRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool ReplyRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplyRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplyRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplyRequest::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ReplyRequest::type() const {
  return *type_;
}
inline void ReplyRequest::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReplyRequest::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReplyRequest::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ReplyRequest::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 expiry = 3;
inline bool ReplyRequest::has_expiry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplyRequest::set_has_expiry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplyRequest::clear_has_expiry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplyRequest::clear_expiry() {
  expiry_ = GOOGLE_LONGLONG(0);
  clear_has_expiry();
}
inline ::google::protobuf::int64 ReplyRequest::expiry() const {
  return expiry_;
}
inline void ReplyRequest::set_expiry(::google::protobuf::int64 value) {
  set_has_expiry();
  expiry_ = value;
}

// optional string topic_id = 4;
inline bool ReplyRequest::has_topic_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReplyRequest::set_has_topic_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReplyRequest::clear_has_topic_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReplyRequest::clear_topic_id() {
  if (topic_id_ != &::google::protobuf::internal::kEmptyString) {
    topic_id_->clear();
  }
  clear_has_topic_id();
}
inline const ::std::string& ReplyRequest::topic_id() const {
  return *topic_id_;
}
inline void ReplyRequest::set_topic_id(const ::std::string& value) {
  set_has_topic_id();
  if (topic_id_ == &::google::protobuf::internal::kEmptyString) {
    topic_id_ = new ::std::string;
  }
  topic_id_->assign(value);
}
inline void ReplyRequest::set_topic_id(const char* value) {
  set_has_topic_id();
  if (topic_id_ == &::google::protobuf::internal::kEmptyString) {
    topic_id_ = new ::std::string;
  }
  topic_id_->assign(value);
}
inline void ReplyRequest::set_topic_id(const char* value, size_t size) {
  set_has_topic_id();
  if (topic_id_ == &::google::protobuf::internal::kEmptyString) {
    topic_id_ = new ::std::string;
  }
  topic_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_topic_id() {
  set_has_topic_id();
  if (topic_id_ == &::google::protobuf::internal::kEmptyString) {
    topic_id_ = new ::std::string;
  }
  return topic_id_;
}
inline ::std::string* ReplyRequest::release_topic_id() {
  clear_has_topic_id();
  if (topic_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topic_id_;
    topic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_topic_id(::std::string* topic_id) {
  if (topic_id_ != &::google::protobuf::internal::kEmptyString) {
    delete topic_id_;
  }
  if (topic_id) {
    set_has_topic_id();
    topic_id_ = topic_id;
  } else {
    clear_has_topic_id();
    topic_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sign = 5;
inline bool ReplyRequest::has_sign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReplyRequest::set_has_sign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReplyRequest::clear_has_sign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReplyRequest::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& ReplyRequest::sign() const {
  return *sign_;
}
inline void ReplyRequest::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void ReplyRequest::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void ReplyRequest::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* ReplyRequest::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string v = 6;
inline bool ReplyRequest::has_v() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReplyRequest::set_has_v() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReplyRequest::clear_has_v() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReplyRequest::clear_v() {
  if (v_ != &::google::protobuf::internal::kEmptyString) {
    v_->clear();
  }
  clear_has_v();
}
inline const ::std::string& ReplyRequest::v() const {
  return *v_;
}
inline void ReplyRequest::set_v(const ::std::string& value) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  v_->assign(value);
}
inline void ReplyRequest::set_v(const char* value) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  v_->assign(value);
}
inline void ReplyRequest::set_v(const char* value, size_t size) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  v_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_v() {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  return v_;
}
inline ::std::string* ReplyRequest::release_v() {
  clear_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = v_;
    v_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_v(::std::string* v) {
  if (v_ != &::google::protobuf::internal::kEmptyString) {
    delete v_;
  }
  if (v) {
    set_has_v();
    v_ = v;
  } else {
    clear_has_v();
    v_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platform = 7;
inline bool ReplyRequest::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReplyRequest::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReplyRequest::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReplyRequest::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& ReplyRequest::platform() const {
  return *platform_;
}
inline void ReplyRequest::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void ReplyRequest::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void ReplyRequest::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* ReplyRequest::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_id = 8;
inline bool ReplyRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReplyRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReplyRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReplyRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ReplyRequest::device_id() const {
  return *device_id_;
}
inline void ReplyRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ReplyRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ReplyRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ReplyRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string authorization = 9;
inline bool ReplyRequest::has_authorization() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReplyRequest::set_has_authorization() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReplyRequest::clear_has_authorization() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReplyRequest::clear_authorization() {
  if (authorization_ != &::google::protobuf::internal::kEmptyString) {
    authorization_->clear();
  }
  clear_has_authorization();
}
inline const ::std::string& ReplyRequest::authorization() const {
  return *authorization_;
}
inline void ReplyRequest::set_authorization(const ::std::string& value) {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  authorization_->assign(value);
}
inline void ReplyRequest::set_authorization(const char* value) {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  authorization_->assign(value);
}
inline void ReplyRequest::set_authorization(const char* value, size_t size) {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  authorization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_authorization() {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  return authorization_;
}
inline ::std::string* ReplyRequest::release_authorization() {
  clear_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authorization_;
    authorization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_authorization(::std::string* authorization) {
  if (authorization_ != &::google::protobuf::internal::kEmptyString) {
    delete authorization_;
  }
  if (authorization) {
    set_has_authorization();
    authorization_ = authorization;
  } else {
    clear_has_authorization();
    authorization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 10;
inline bool ReplyRequest::has_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReplyRequest::set_has_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReplyRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReplyRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ReplyRequest::data() const {
  return *data_;
}
inline void ReplyRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReplyRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReplyRequest::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ReplyRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReplyResponse

// optional string cid = 1;
inline bool ReplyResponse::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplyResponse::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplyResponse::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplyResponse::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& ReplyResponse::cid() const {
  return *cid_;
}
inline void ReplyResponse::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void ReplyResponse::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void ReplyResponse::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyResponse::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* ReplyResponse::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyResponse::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool ReplyResponse::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplyResponse::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplyResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplyResponse::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ReplyResponse::type() const {
  return *type_;
}
inline void ReplyResponse::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReplyResponse::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ReplyResponse::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyResponse::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ReplyResponse::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyResponse::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 3;
inline bool ReplyResponse::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplyResponse::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplyResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplyResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ReplyResponse::data() const {
  return *data_;
}
inline void ReplyResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReplyResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ReplyResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplyResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ReplyResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplyResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostTopicRequest

// optional string cid = 1;
inline bool PostTopicRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostTopicRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostTopicRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostTopicRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& PostTopicRequest::cid() const {
  return *cid_;
}
inline void PostTopicRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PostTopicRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PostTopicRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* PostTopicRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool PostTopicRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostTopicRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostTopicRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostTopicRequest::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& PostTopicRequest::type() const {
  return *type_;
}
inline void PostTopicRequest::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void PostTopicRequest::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void PostTopicRequest::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* PostTopicRequest::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 expiry = 3;
inline bool PostTopicRequest::has_expiry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostTopicRequest::set_has_expiry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostTopicRequest::clear_has_expiry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostTopicRequest::clear_expiry() {
  expiry_ = GOOGLE_LONGLONG(0);
  clear_has_expiry();
}
inline ::google::protobuf::int64 PostTopicRequest::expiry() const {
  return expiry_;
}
inline void PostTopicRequest::set_expiry(::google::protobuf::int64 value) {
  set_has_expiry();
  expiry_ = value;
}

// optional string forum_id = 4;
inline bool PostTopicRequest::has_forum_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PostTopicRequest::set_has_forum_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PostTopicRequest::clear_has_forum_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PostTopicRequest::clear_forum_id() {
  if (forum_id_ != &::google::protobuf::internal::kEmptyString) {
    forum_id_->clear();
  }
  clear_has_forum_id();
}
inline const ::std::string& PostTopicRequest::forum_id() const {
  return *forum_id_;
}
inline void PostTopicRequest::set_forum_id(const ::std::string& value) {
  set_has_forum_id();
  if (forum_id_ == &::google::protobuf::internal::kEmptyString) {
    forum_id_ = new ::std::string;
  }
  forum_id_->assign(value);
}
inline void PostTopicRequest::set_forum_id(const char* value) {
  set_has_forum_id();
  if (forum_id_ == &::google::protobuf::internal::kEmptyString) {
    forum_id_ = new ::std::string;
  }
  forum_id_->assign(value);
}
inline void PostTopicRequest::set_forum_id(const char* value, size_t size) {
  set_has_forum_id();
  if (forum_id_ == &::google::protobuf::internal::kEmptyString) {
    forum_id_ = new ::std::string;
  }
  forum_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_forum_id() {
  set_has_forum_id();
  if (forum_id_ == &::google::protobuf::internal::kEmptyString) {
    forum_id_ = new ::std::string;
  }
  return forum_id_;
}
inline ::std::string* PostTopicRequest::release_forum_id() {
  clear_has_forum_id();
  if (forum_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = forum_id_;
    forum_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_forum_id(::std::string* forum_id) {
  if (forum_id_ != &::google::protobuf::internal::kEmptyString) {
    delete forum_id_;
  }
  if (forum_id) {
    set_has_forum_id();
    forum_id_ = forum_id;
  } else {
    clear_has_forum_id();
    forum_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sign = 5;
inline bool PostTopicRequest::has_sign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PostTopicRequest::set_has_sign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PostTopicRequest::clear_has_sign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PostTopicRequest::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& PostTopicRequest::sign() const {
  return *sign_;
}
inline void PostTopicRequest::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void PostTopicRequest::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void PostTopicRequest::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* PostTopicRequest::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string v = 6;
inline bool PostTopicRequest::has_v() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PostTopicRequest::set_has_v() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PostTopicRequest::clear_has_v() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PostTopicRequest::clear_v() {
  if (v_ != &::google::protobuf::internal::kEmptyString) {
    v_->clear();
  }
  clear_has_v();
}
inline const ::std::string& PostTopicRequest::v() const {
  return *v_;
}
inline void PostTopicRequest::set_v(const ::std::string& value) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  v_->assign(value);
}
inline void PostTopicRequest::set_v(const char* value) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  v_->assign(value);
}
inline void PostTopicRequest::set_v(const char* value, size_t size) {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  v_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_v() {
  set_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    v_ = new ::std::string;
  }
  return v_;
}
inline ::std::string* PostTopicRequest::release_v() {
  clear_has_v();
  if (v_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = v_;
    v_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_v(::std::string* v) {
  if (v_ != &::google::protobuf::internal::kEmptyString) {
    delete v_;
  }
  if (v) {
    set_has_v();
    v_ = v;
  } else {
    clear_has_v();
    v_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platform = 7;
inline bool PostTopicRequest::has_platform() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PostTopicRequest::set_has_platform() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PostTopicRequest::clear_has_platform() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PostTopicRequest::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& PostTopicRequest::platform() const {
  return *platform_;
}
inline void PostTopicRequest::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void PostTopicRequest::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void PostTopicRequest::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* PostTopicRequest::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_id = 8;
inline bool PostTopicRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PostTopicRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PostTopicRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PostTopicRequest::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& PostTopicRequest::device_id() const {
  return *device_id_;
}
inline void PostTopicRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void PostTopicRequest::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void PostTopicRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* PostTopicRequest::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string authorization = 9;
inline bool PostTopicRequest::has_authorization() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PostTopicRequest::set_has_authorization() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PostTopicRequest::clear_has_authorization() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PostTopicRequest::clear_authorization() {
  if (authorization_ != &::google::protobuf::internal::kEmptyString) {
    authorization_->clear();
  }
  clear_has_authorization();
}
inline const ::std::string& PostTopicRequest::authorization() const {
  return *authorization_;
}
inline void PostTopicRequest::set_authorization(const ::std::string& value) {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  authorization_->assign(value);
}
inline void PostTopicRequest::set_authorization(const char* value) {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  authorization_->assign(value);
}
inline void PostTopicRequest::set_authorization(const char* value, size_t size) {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  authorization_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_authorization() {
  set_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    authorization_ = new ::std::string;
  }
  return authorization_;
}
inline ::std::string* PostTopicRequest::release_authorization() {
  clear_has_authorization();
  if (authorization_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authorization_;
    authorization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_authorization(::std::string* authorization) {
  if (authorization_ != &::google::protobuf::internal::kEmptyString) {
    delete authorization_;
  }
  if (authorization) {
    set_has_authorization();
    authorization_ = authorization;
  } else {
    clear_has_authorization();
    authorization_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 10;
inline bool PostTopicRequest::has_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PostTopicRequest::set_has_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PostTopicRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PostTopicRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PostTopicRequest::data() const {
  return *data_;
}
inline void PostTopicRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PostTopicRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PostTopicRequest::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* PostTopicRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PostTopicResponse

// optional string cid = 1;
inline bool PostTopicResponse::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostTopicResponse::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostTopicResponse::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostTopicResponse::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& PostTopicResponse::cid() const {
  return *cid_;
}
inline void PostTopicResponse::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PostTopicResponse::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PostTopicResponse::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicResponse::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* PostTopicResponse::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicResponse::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 2;
inline bool PostTopicResponse::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostTopicResponse::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostTopicResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostTopicResponse::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& PostTopicResponse::type() const {
  return *type_;
}
inline void PostTopicResponse::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void PostTopicResponse::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void PostTopicResponse::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicResponse::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* PostTopicResponse::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicResponse::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 3;
inline bool PostTopicResponse::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostTopicResponse::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostTopicResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostTopicResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PostTopicResponse::data() const {
  return *data_;
}
inline void PostTopicResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PostTopicResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PostTopicResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostTopicResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* PostTopicResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PostTopicResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PublicServiceRequest

// optional string cid = 1;
inline bool PublicServiceRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicServiceRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicServiceRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicServiceRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& PublicServiceRequest::cid() const {
  return *cid_;
}
inline void PublicServiceRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PublicServiceRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PublicServiceRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicServiceRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* PublicServiceRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PublicServiceRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string service_id = 2;
inline bool PublicServiceRequest::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicServiceRequest::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicServiceRequest::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicServiceRequest::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& PublicServiceRequest::service_id() const {
  return *service_id_;
}
inline void PublicServiceRequest::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void PublicServiceRequest::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void PublicServiceRequest::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicServiceRequest::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* PublicServiceRequest::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PublicServiceRequest::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data = 3;
inline bool PublicServiceRequest::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublicServiceRequest::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PublicServiceRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PublicServiceRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PublicServiceRequest::data() const {
  return *data_;
}
inline void PublicServiceRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PublicServiceRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PublicServiceRequest::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicServiceRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* PublicServiceRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PublicServiceRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PublicServiceResponse

// optional string cid = 1;
inline bool PublicServiceResponse::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicServiceResponse::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicServiceResponse::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicServiceResponse::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& PublicServiceResponse::cid() const {
  return *cid_;
}
inline void PublicServiceResponse::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PublicServiceResponse::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PublicServiceResponse::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicServiceResponse::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* PublicServiceResponse::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PublicServiceResponse::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string service_id = 2;
inline bool PublicServiceResponse::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicServiceResponse::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicServiceResponse::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicServiceResponse::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& PublicServiceResponse::service_id() const {
  return *service_id_;
}
inline void PublicServiceResponse::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void PublicServiceResponse::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void PublicServiceResponse::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicServiceResponse::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* PublicServiceResponse::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PublicServiceResponse::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data = 3;
inline bool PublicServiceResponse::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublicServiceResponse::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PublicServiceResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PublicServiceResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PublicServiceResponse::data() const {
  return *data_;
}
inline void PublicServiceResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PublicServiceResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PublicServiceResponse::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicServiceResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* PublicServiceResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PublicServiceResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time = 4;
inline bool PublicServiceResponse::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PublicServiceResponse::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PublicServiceResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PublicServiceResponse::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 PublicServiceResponse::time() const {
  return time_;
}
inline void PublicServiceResponse::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// GroupLBSNearRequest

// optional string cid = 1;
inline bool GroupLBSNearRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupLBSNearRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupLBSNearRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupLBSNearRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& GroupLBSNearRequest::cid() const {
  return *cid_;
}
inline void GroupLBSNearRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupLBSNearRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupLBSNearRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupLBSNearRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* GroupLBSNearRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupLBSNearRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double lat = 2;
inline bool GroupLBSNearRequest::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupLBSNearRequest::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupLBSNearRequest::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupLBSNearRequest::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double GroupLBSNearRequest::lat() const {
  return lat_;
}
inline void GroupLBSNearRequest::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double long = 3;
inline bool GroupLBSNearRequest::has_long_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupLBSNearRequest::set_has_long_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupLBSNearRequest::clear_has_long_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupLBSNearRequest::clear_long_() {
  long__ = 0;
  clear_has_long_();
}
inline double GroupLBSNearRequest::long_() const {
  return long__;
}
inline void GroupLBSNearRequest::set_long_(double value) {
  set_has_long_();
  long__ = value;
}

// optional int32 start = 4;
inline bool GroupLBSNearRequest::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupLBSNearRequest::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupLBSNearRequest::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupLBSNearRequest::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 GroupLBSNearRequest::start() const {
  return start_;
}
inline void GroupLBSNearRequest::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// optional int32 limit = 5;
inline bool GroupLBSNearRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupLBSNearRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupLBSNearRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupLBSNearRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 GroupLBSNearRequest::limit() const {
  return limit_;
}
inline void GroupLBSNearRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 max_distance = 6;
inline bool GroupLBSNearRequest::has_max_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupLBSNearRequest::set_has_max_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupLBSNearRequest::clear_has_max_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupLBSNearRequest::clear_max_distance() {
  max_distance_ = 0;
  clear_has_max_distance();
}
inline ::google::protobuf::int32 GroupLBSNearRequest::max_distance() const {
  return max_distance_;
}
inline void GroupLBSNearRequest::set_max_distance(::google::protobuf::int32 value) {
  set_has_max_distance();
  max_distance_ = value;
}

// -------------------------------------------------------------------

// GroupLBSNearResponse

// optional string cid = 1;
inline bool GroupLBSNearResponse::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupLBSNearResponse::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupLBSNearResponse::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupLBSNearResponse::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& GroupLBSNearResponse::cid() const {
  return *cid_;
}
inline void GroupLBSNearResponse::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupLBSNearResponse::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupLBSNearResponse::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupLBSNearResponse::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* GroupLBSNearResponse::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupLBSNearResponse::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 2;
inline bool GroupLBSNearResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupLBSNearResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupLBSNearResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupLBSNearResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 GroupLBSNearResponse::status() const {
  return status_;
}
inline void GroupLBSNearResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string data = 3;
inline bool GroupLBSNearResponse::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupLBSNearResponse::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupLBSNearResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupLBSNearResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& GroupLBSNearResponse::data() const {
  return *data_;
}
inline void GroupLBSNearResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GroupLBSNearResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GroupLBSNearResponse::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupLBSNearResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* GroupLBSNearResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupLBSNearResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupCityRequest

// optional string cid = 1;
inline bool GroupCityRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupCityRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupCityRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupCityRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& GroupCityRequest::cid() const {
  return *cid_;
}
inline void GroupCityRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupCityRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupCityRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupCityRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* GroupCityRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupCityRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 2;
inline bool GroupCityRequest::has_city() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupCityRequest::set_has_city() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupCityRequest::clear_has_city() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupCityRequest::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& GroupCityRequest::city() const {
  return *city_;
}
inline void GroupCityRequest::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GroupCityRequest::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void GroupCityRequest::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupCityRequest::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* GroupCityRequest::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupCityRequest::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 start = 3;
inline bool GroupCityRequest::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupCityRequest::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupCityRequest::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupCityRequest::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 GroupCityRequest::start() const {
  return start_;
}
inline void GroupCityRequest::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// optional int32 limit = 4;
inline bool GroupCityRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupCityRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupCityRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupCityRequest::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 GroupCityRequest::limit() const {
  return limit_;
}
inline void GroupCityRequest::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// -------------------------------------------------------------------

// GroupCityResponse

// optional string cid = 1;
inline bool GroupCityResponse::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupCityResponse::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupCityResponse::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupCityResponse::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& GroupCityResponse::cid() const {
  return *cid_;
}
inline void GroupCityResponse::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupCityResponse::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GroupCityResponse::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupCityResponse::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* GroupCityResponse::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupCityResponse::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 2;
inline bool GroupCityResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupCityResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupCityResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupCityResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 GroupCityResponse::status() const {
  return status_;
}
inline void GroupCityResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string data = 3;
inline bool GroupCityResponse::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupCityResponse::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupCityResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupCityResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& GroupCityResponse::data() const {
  return *data_;
}
inline void GroupCityResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GroupCityResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GroupCityResponse::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupCityResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* GroupCityResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupCityResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PythonCoreRequest

// optional string cid = 1;
inline bool PythonCoreRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PythonCoreRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PythonCoreRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PythonCoreRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& PythonCoreRequest::cid() const {
  return *cid_;
}
inline void PythonCoreRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PythonCoreRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PythonCoreRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PythonCoreRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* PythonCoreRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PythonCoreRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string json_request = 2;
inline bool PythonCoreRequest::has_json_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PythonCoreRequest::set_has_json_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PythonCoreRequest::clear_has_json_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PythonCoreRequest::clear_json_request() {
  if (json_request_ != &::google::protobuf::internal::kEmptyString) {
    json_request_->clear();
  }
  clear_has_json_request();
}
inline const ::std::string& PythonCoreRequest::json_request() const {
  return *json_request_;
}
inline void PythonCoreRequest::set_json_request(const ::std::string& value) {
  set_has_json_request();
  if (json_request_ == &::google::protobuf::internal::kEmptyString) {
    json_request_ = new ::std::string;
  }
  json_request_->assign(value);
}
inline void PythonCoreRequest::set_json_request(const char* value) {
  set_has_json_request();
  if (json_request_ == &::google::protobuf::internal::kEmptyString) {
    json_request_ = new ::std::string;
  }
  json_request_->assign(value);
}
inline void PythonCoreRequest::set_json_request(const char* value, size_t size) {
  set_has_json_request();
  if (json_request_ == &::google::protobuf::internal::kEmptyString) {
    json_request_ = new ::std::string;
  }
  json_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PythonCoreRequest::mutable_json_request() {
  set_has_json_request();
  if (json_request_ == &::google::protobuf::internal::kEmptyString) {
    json_request_ = new ::std::string;
  }
  return json_request_;
}
inline ::std::string* PythonCoreRequest::release_json_request() {
  clear_has_json_request();
  if (json_request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = json_request_;
    json_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PythonCoreRequest::set_allocated_json_request(::std::string* json_request) {
  if (json_request_ != &::google::protobuf::internal::kEmptyString) {
    delete json_request_;
  }
  if (json_request) {
    set_has_json_request();
    json_request_ = json_request;
  } else {
    clear_has_json_request();
    json_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string module_name = 3;
inline bool PythonCoreRequest::has_module_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PythonCoreRequest::set_has_module_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PythonCoreRequest::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PythonCoreRequest::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& PythonCoreRequest::module_name() const {
  return *module_name_;
}
inline void PythonCoreRequest::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void PythonCoreRequest::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void PythonCoreRequest::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PythonCoreRequest::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* PythonCoreRequest::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PythonCoreRequest::set_allocated_module_name(::std::string* module_name) {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    delete module_name_;
  }
  if (module_name) {
    set_has_module_name();
    module_name_ = module_name;
  } else {
    clear_has_module_name();
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string function_name = 4;
inline bool PythonCoreRequest::has_function_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PythonCoreRequest::set_has_function_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PythonCoreRequest::clear_has_function_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PythonCoreRequest::clear_function_name() {
  if (function_name_ != &::google::protobuf::internal::kEmptyString) {
    function_name_->clear();
  }
  clear_has_function_name();
}
inline const ::std::string& PythonCoreRequest::function_name() const {
  return *function_name_;
}
inline void PythonCoreRequest::set_function_name(const ::std::string& value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
}
inline void PythonCoreRequest::set_function_name(const char* value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
}
inline void PythonCoreRequest::set_function_name(const char* value, size_t size) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PythonCoreRequest::mutable_function_name() {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    function_name_ = new ::std::string;
  }
  return function_name_;
}
inline ::std::string* PythonCoreRequest::release_function_name() {
  clear_has_function_name();
  if (function_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = function_name_;
    function_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PythonCoreRequest::set_allocated_function_name(::std::string* function_name) {
  if (function_name_ != &::google::protobuf::internal::kEmptyString) {
    delete function_name_;
  }
  if (function_name) {
    set_has_function_name();
    function_name_ = function_name;
  } else {
    clear_has_function_name();
    function_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PythonCoreResponse

// optional string cid = 1;
inline bool PythonCoreResponse::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PythonCoreResponse::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PythonCoreResponse::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PythonCoreResponse::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& PythonCoreResponse::cid() const {
  return *cid_;
}
inline void PythonCoreResponse::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PythonCoreResponse::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void PythonCoreResponse::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PythonCoreResponse::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* PythonCoreResponse::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PythonCoreResponse::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string json_response = 2;
inline bool PythonCoreResponse::has_json_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PythonCoreResponse::set_has_json_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PythonCoreResponse::clear_has_json_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PythonCoreResponse::clear_json_response() {
  if (json_response_ != &::google::protobuf::internal::kEmptyString) {
    json_response_->clear();
  }
  clear_has_json_response();
}
inline const ::std::string& PythonCoreResponse::json_response() const {
  return *json_response_;
}
inline void PythonCoreResponse::set_json_response(const ::std::string& value) {
  set_has_json_response();
  if (json_response_ == &::google::protobuf::internal::kEmptyString) {
    json_response_ = new ::std::string;
  }
  json_response_->assign(value);
}
inline void PythonCoreResponse::set_json_response(const char* value) {
  set_has_json_response();
  if (json_response_ == &::google::protobuf::internal::kEmptyString) {
    json_response_ = new ::std::string;
  }
  json_response_->assign(value);
}
inline void PythonCoreResponse::set_json_response(const char* value, size_t size) {
  set_has_json_response();
  if (json_response_ == &::google::protobuf::internal::kEmptyString) {
    json_response_ = new ::std::string;
  }
  json_response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PythonCoreResponse::mutable_json_response() {
  set_has_json_response();
  if (json_response_ == &::google::protobuf::internal::kEmptyString) {
    json_response_ = new ::std::string;
  }
  return json_response_;
}
inline ::std::string* PythonCoreResponse::release_json_response() {
  clear_has_json_response();
  if (json_response_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = json_response_;
    json_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PythonCoreResponse::set_allocated_json_response(::std::string* json_response) {
  if (json_response_ != &::google::protobuf::internal::kEmptyString) {
    delete json_response_;
  }
  if (json_response) {
    set_has_json_response();
    json_response_ = json_response;
  } else {
    clear_has_json_response();
    json_response_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 3;
inline bool PythonCoreResponse::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PythonCoreResponse::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PythonCoreResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PythonCoreResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 PythonCoreResponse::status() const {
  return status_;
}
inline void PythonCoreResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ServicePacket

// required int32 type = 1;
inline bool ServicePacket::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServicePacket::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServicePacket::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServicePacket::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ServicePacket::type() const {
  return type_;
}
inline void ServicePacket::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional .ReplyRequest reply_request = 2;
inline bool ServicePacket::has_reply_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServicePacket::set_has_reply_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServicePacket::clear_has_reply_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServicePacket::clear_reply_request() {
  if (reply_request_ != NULL) reply_request_->::ReplyRequest::Clear();
  clear_has_reply_request();
}
inline const ::ReplyRequest& ServicePacket::reply_request() const {
  return reply_request_ != NULL ? *reply_request_ : *default_instance_->reply_request_;
}
inline ::ReplyRequest* ServicePacket::mutable_reply_request() {
  set_has_reply_request();
  if (reply_request_ == NULL) reply_request_ = new ::ReplyRequest;
  return reply_request_;
}
inline ::ReplyRequest* ServicePacket::release_reply_request() {
  clear_has_reply_request();
  ::ReplyRequest* temp = reply_request_;
  reply_request_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_reply_request(::ReplyRequest* reply_request) {
  delete reply_request_;
  reply_request_ = reply_request;
  if (reply_request) {
    set_has_reply_request();
  } else {
    clear_has_reply_request();
  }
}

// optional .ReplyResponse reply_response = 3;
inline bool ServicePacket::has_reply_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServicePacket::set_has_reply_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServicePacket::clear_has_reply_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServicePacket::clear_reply_response() {
  if (reply_response_ != NULL) reply_response_->::ReplyResponse::Clear();
  clear_has_reply_response();
}
inline const ::ReplyResponse& ServicePacket::reply_response() const {
  return reply_response_ != NULL ? *reply_response_ : *default_instance_->reply_response_;
}
inline ::ReplyResponse* ServicePacket::mutable_reply_response() {
  set_has_reply_response();
  if (reply_response_ == NULL) reply_response_ = new ::ReplyResponse;
  return reply_response_;
}
inline ::ReplyResponse* ServicePacket::release_reply_response() {
  clear_has_reply_response();
  ::ReplyResponse* temp = reply_response_;
  reply_response_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_reply_response(::ReplyResponse* reply_response) {
  delete reply_response_;
  reply_response_ = reply_response;
  if (reply_response) {
    set_has_reply_response();
  } else {
    clear_has_reply_response();
  }
}

// optional .PostTopicRequest post_topic_request = 4;
inline bool ServicePacket::has_post_topic_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServicePacket::set_has_post_topic_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServicePacket::clear_has_post_topic_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServicePacket::clear_post_topic_request() {
  if (post_topic_request_ != NULL) post_topic_request_->::PostTopicRequest::Clear();
  clear_has_post_topic_request();
}
inline const ::PostTopicRequest& ServicePacket::post_topic_request() const {
  return post_topic_request_ != NULL ? *post_topic_request_ : *default_instance_->post_topic_request_;
}
inline ::PostTopicRequest* ServicePacket::mutable_post_topic_request() {
  set_has_post_topic_request();
  if (post_topic_request_ == NULL) post_topic_request_ = new ::PostTopicRequest;
  return post_topic_request_;
}
inline ::PostTopicRequest* ServicePacket::release_post_topic_request() {
  clear_has_post_topic_request();
  ::PostTopicRequest* temp = post_topic_request_;
  post_topic_request_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_post_topic_request(::PostTopicRequest* post_topic_request) {
  delete post_topic_request_;
  post_topic_request_ = post_topic_request;
  if (post_topic_request) {
    set_has_post_topic_request();
  } else {
    clear_has_post_topic_request();
  }
}

// optional .PostTopicResponse post_topic_response = 5;
inline bool ServicePacket::has_post_topic_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServicePacket::set_has_post_topic_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServicePacket::clear_has_post_topic_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServicePacket::clear_post_topic_response() {
  if (post_topic_response_ != NULL) post_topic_response_->::PostTopicResponse::Clear();
  clear_has_post_topic_response();
}
inline const ::PostTopicResponse& ServicePacket::post_topic_response() const {
  return post_topic_response_ != NULL ? *post_topic_response_ : *default_instance_->post_topic_response_;
}
inline ::PostTopicResponse* ServicePacket::mutable_post_topic_response() {
  set_has_post_topic_response();
  if (post_topic_response_ == NULL) post_topic_response_ = new ::PostTopicResponse;
  return post_topic_response_;
}
inline ::PostTopicResponse* ServicePacket::release_post_topic_response() {
  clear_has_post_topic_response();
  ::PostTopicResponse* temp = post_topic_response_;
  post_topic_response_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_post_topic_response(::PostTopicResponse* post_topic_response) {
  delete post_topic_response_;
  post_topic_response_ = post_topic_response;
  if (post_topic_response) {
    set_has_post_topic_response();
  } else {
    clear_has_post_topic_response();
  }
}

// optional .PublicServiceRequest public_service_request = 6;
inline bool ServicePacket::has_public_service_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServicePacket::set_has_public_service_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServicePacket::clear_has_public_service_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServicePacket::clear_public_service_request() {
  if (public_service_request_ != NULL) public_service_request_->::PublicServiceRequest::Clear();
  clear_has_public_service_request();
}
inline const ::PublicServiceRequest& ServicePacket::public_service_request() const {
  return public_service_request_ != NULL ? *public_service_request_ : *default_instance_->public_service_request_;
}
inline ::PublicServiceRequest* ServicePacket::mutable_public_service_request() {
  set_has_public_service_request();
  if (public_service_request_ == NULL) public_service_request_ = new ::PublicServiceRequest;
  return public_service_request_;
}
inline ::PublicServiceRequest* ServicePacket::release_public_service_request() {
  clear_has_public_service_request();
  ::PublicServiceRequest* temp = public_service_request_;
  public_service_request_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_public_service_request(::PublicServiceRequest* public_service_request) {
  delete public_service_request_;
  public_service_request_ = public_service_request;
  if (public_service_request) {
    set_has_public_service_request();
  } else {
    clear_has_public_service_request();
  }
}

// optional .PublicServiceResponse public_service_response = 7;
inline bool ServicePacket::has_public_service_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServicePacket::set_has_public_service_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServicePacket::clear_has_public_service_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServicePacket::clear_public_service_response() {
  if (public_service_response_ != NULL) public_service_response_->::PublicServiceResponse::Clear();
  clear_has_public_service_response();
}
inline const ::PublicServiceResponse& ServicePacket::public_service_response() const {
  return public_service_response_ != NULL ? *public_service_response_ : *default_instance_->public_service_response_;
}
inline ::PublicServiceResponse* ServicePacket::mutable_public_service_response() {
  set_has_public_service_response();
  if (public_service_response_ == NULL) public_service_response_ = new ::PublicServiceResponse;
  return public_service_response_;
}
inline ::PublicServiceResponse* ServicePacket::release_public_service_response() {
  clear_has_public_service_response();
  ::PublicServiceResponse* temp = public_service_response_;
  public_service_response_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_public_service_response(::PublicServiceResponse* public_service_response) {
  delete public_service_response_;
  public_service_response_ = public_service_response;
  if (public_service_response) {
    set_has_public_service_response();
  } else {
    clear_has_public_service_response();
  }
}

// optional .GroupLBSNearRequest group_lbs_near_request = 8;
inline bool ServicePacket::has_group_lbs_near_request() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServicePacket::set_has_group_lbs_near_request() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServicePacket::clear_has_group_lbs_near_request() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServicePacket::clear_group_lbs_near_request() {
  if (group_lbs_near_request_ != NULL) group_lbs_near_request_->::GroupLBSNearRequest::Clear();
  clear_has_group_lbs_near_request();
}
inline const ::GroupLBSNearRequest& ServicePacket::group_lbs_near_request() const {
  return group_lbs_near_request_ != NULL ? *group_lbs_near_request_ : *default_instance_->group_lbs_near_request_;
}
inline ::GroupLBSNearRequest* ServicePacket::mutable_group_lbs_near_request() {
  set_has_group_lbs_near_request();
  if (group_lbs_near_request_ == NULL) group_lbs_near_request_ = new ::GroupLBSNearRequest;
  return group_lbs_near_request_;
}
inline ::GroupLBSNearRequest* ServicePacket::release_group_lbs_near_request() {
  clear_has_group_lbs_near_request();
  ::GroupLBSNearRequest* temp = group_lbs_near_request_;
  group_lbs_near_request_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_group_lbs_near_request(::GroupLBSNearRequest* group_lbs_near_request) {
  delete group_lbs_near_request_;
  group_lbs_near_request_ = group_lbs_near_request;
  if (group_lbs_near_request) {
    set_has_group_lbs_near_request();
  } else {
    clear_has_group_lbs_near_request();
  }
}

// optional .GroupLBSNearResponse group_lbs_near_response = 9;
inline bool ServicePacket::has_group_lbs_near_response() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServicePacket::set_has_group_lbs_near_response() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServicePacket::clear_has_group_lbs_near_response() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServicePacket::clear_group_lbs_near_response() {
  if (group_lbs_near_response_ != NULL) group_lbs_near_response_->::GroupLBSNearResponse::Clear();
  clear_has_group_lbs_near_response();
}
inline const ::GroupLBSNearResponse& ServicePacket::group_lbs_near_response() const {
  return group_lbs_near_response_ != NULL ? *group_lbs_near_response_ : *default_instance_->group_lbs_near_response_;
}
inline ::GroupLBSNearResponse* ServicePacket::mutable_group_lbs_near_response() {
  set_has_group_lbs_near_response();
  if (group_lbs_near_response_ == NULL) group_lbs_near_response_ = new ::GroupLBSNearResponse;
  return group_lbs_near_response_;
}
inline ::GroupLBSNearResponse* ServicePacket::release_group_lbs_near_response() {
  clear_has_group_lbs_near_response();
  ::GroupLBSNearResponse* temp = group_lbs_near_response_;
  group_lbs_near_response_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_group_lbs_near_response(::GroupLBSNearResponse* group_lbs_near_response) {
  delete group_lbs_near_response_;
  group_lbs_near_response_ = group_lbs_near_response;
  if (group_lbs_near_response) {
    set_has_group_lbs_near_response();
  } else {
    clear_has_group_lbs_near_response();
  }
}

// optional .GroupCityRequest group_city_request = 10;
inline bool ServicePacket::has_group_city_request() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ServicePacket::set_has_group_city_request() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ServicePacket::clear_has_group_city_request() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ServicePacket::clear_group_city_request() {
  if (group_city_request_ != NULL) group_city_request_->::GroupCityRequest::Clear();
  clear_has_group_city_request();
}
inline const ::GroupCityRequest& ServicePacket::group_city_request() const {
  return group_city_request_ != NULL ? *group_city_request_ : *default_instance_->group_city_request_;
}
inline ::GroupCityRequest* ServicePacket::mutable_group_city_request() {
  set_has_group_city_request();
  if (group_city_request_ == NULL) group_city_request_ = new ::GroupCityRequest;
  return group_city_request_;
}
inline ::GroupCityRequest* ServicePacket::release_group_city_request() {
  clear_has_group_city_request();
  ::GroupCityRequest* temp = group_city_request_;
  group_city_request_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_group_city_request(::GroupCityRequest* group_city_request) {
  delete group_city_request_;
  group_city_request_ = group_city_request;
  if (group_city_request) {
    set_has_group_city_request();
  } else {
    clear_has_group_city_request();
  }
}

// optional .GroupCityResponse group_city_response = 11;
inline bool ServicePacket::has_group_city_response() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ServicePacket::set_has_group_city_response() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ServicePacket::clear_has_group_city_response() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ServicePacket::clear_group_city_response() {
  if (group_city_response_ != NULL) group_city_response_->::GroupCityResponse::Clear();
  clear_has_group_city_response();
}
inline const ::GroupCityResponse& ServicePacket::group_city_response() const {
  return group_city_response_ != NULL ? *group_city_response_ : *default_instance_->group_city_response_;
}
inline ::GroupCityResponse* ServicePacket::mutable_group_city_response() {
  set_has_group_city_response();
  if (group_city_response_ == NULL) group_city_response_ = new ::GroupCityResponse;
  return group_city_response_;
}
inline ::GroupCityResponse* ServicePacket::release_group_city_response() {
  clear_has_group_city_response();
  ::GroupCityResponse* temp = group_city_response_;
  group_city_response_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_group_city_response(::GroupCityResponse* group_city_response) {
  delete group_city_response_;
  group_city_response_ = group_city_response;
  if (group_city_response) {
    set_has_group_city_response();
  } else {
    clear_has_group_city_response();
  }
}

// optional .PythonCoreRequest python_core_request = 12;
inline bool ServicePacket::has_python_core_request() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ServicePacket::set_has_python_core_request() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ServicePacket::clear_has_python_core_request() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ServicePacket::clear_python_core_request() {
  if (python_core_request_ != NULL) python_core_request_->::PythonCoreRequest::Clear();
  clear_has_python_core_request();
}
inline const ::PythonCoreRequest& ServicePacket::python_core_request() const {
  return python_core_request_ != NULL ? *python_core_request_ : *default_instance_->python_core_request_;
}
inline ::PythonCoreRequest* ServicePacket::mutable_python_core_request() {
  set_has_python_core_request();
  if (python_core_request_ == NULL) python_core_request_ = new ::PythonCoreRequest;
  return python_core_request_;
}
inline ::PythonCoreRequest* ServicePacket::release_python_core_request() {
  clear_has_python_core_request();
  ::PythonCoreRequest* temp = python_core_request_;
  python_core_request_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_python_core_request(::PythonCoreRequest* python_core_request) {
  delete python_core_request_;
  python_core_request_ = python_core_request;
  if (python_core_request) {
    set_has_python_core_request();
  } else {
    clear_has_python_core_request();
  }
}

// optional .PythonCoreResponse python_core_response = 13;
inline bool ServicePacket::has_python_core_response() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ServicePacket::set_has_python_core_response() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ServicePacket::clear_has_python_core_response() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ServicePacket::clear_python_core_response() {
  if (python_core_response_ != NULL) python_core_response_->::PythonCoreResponse::Clear();
  clear_has_python_core_response();
}
inline const ::PythonCoreResponse& ServicePacket::python_core_response() const {
  return python_core_response_ != NULL ? *python_core_response_ : *default_instance_->python_core_response_;
}
inline ::PythonCoreResponse* ServicePacket::mutable_python_core_response() {
  set_has_python_core_response();
  if (python_core_response_ == NULL) python_core_response_ = new ::PythonCoreResponse;
  return python_core_response_;
}
inline ::PythonCoreResponse* ServicePacket::release_python_core_response() {
  clear_has_python_core_response();
  ::PythonCoreResponse* temp = python_core_response_;
  python_core_response_ = NULL;
  return temp;
}
inline void ServicePacket::set_allocated_python_core_response(::PythonCoreResponse* python_core_response) {
  delete python_core_response_;
  python_core_response_ = python_core_response;
  if (python_core_response) {
    set_has_python_core_response();
  } else {
    clear_has_python_core_response();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ServicePacket_2eproto__INCLUDED
